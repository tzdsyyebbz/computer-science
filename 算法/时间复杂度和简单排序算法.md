# 1 认识时间复杂度

常数时间的操作

一个操作如果和样本的数据量无关，每次都是**固定时间**完成操作，那就叫**常数操作**。



时间复杂度为一个算法流程中，常数操作的数量的指标。常用O表示。具体来说，对于一个算法流程，写出该算法发生了多少次常数操作的表达式。



在表达式中，只要高阶项，不要低阶项，也不要高阶项的系数，剩下部分如果为***f(N)***，那么时间复杂度就为***O(f(N))***。



评价一个算法的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是“常数项时间”。这个常数项时间的评价需要**实际**运行测试，因为不同的常数操作需要不同的常数时间，如乘法操作和位运算操作需要的时间是不同的。



# 2 简单排序算法

## 2.1 选择排序与冒泡排序时间复杂度与空间复杂度分析

时间复杂度**O(n^2)**，空间复杂度**O(1)**

选择排序代码如下：

```java
public class SelectSort{
    public static void code_selectSort(int[] arr){
        
        if(arr == null || arr.length < 2){
            return;
        }
        
        for(int i = 0;i < arr.length - 1;i++){
            
            int minIndex = i;
            int min = arr[i];
            for(int j = i + 1;j < arr.length;j++){
                if(arr[j] < min){
                    minIndex = j
                    min = arr[j];
                }
            }
            
            if(minIndex != i){
                arr[minIndex] = arr[i];
                arr[i] = min;
            }
            
        }
    }
}
```

冒泡排序代码如下：

```java
public class BubbleSort{
    public static void code_bubbleSort(int[] arr){
        
        if(arr == null || arr.length < 2){
            return;
        }
        
        for(int i = arr.length - 1;i > 0;i--){
            for(int j = 0;j < i;j++){
                if(arr[j] > arr[j + 1]){
                    swap(arr,j,j + 1);
                }
            }
        }
    }
    /**
    attention:i≠j
    if equals，arr[i]=0,arr[j]=0
    尽量不使用这种方法，使用temp交换
    */
    public static void swap(int[] arr,int i,int j){
     	arr[i] = arr[i] ^ arr[j];
        arr[j] = arr[i] ^ arr[j];
        arr[i] = arr[i] ^ arr[j];
    }
}
```

## 2.2插入排序细节的讲解与复杂度分析

时间复杂度**O(N^2)**，空间复杂度**O(1)**

算法流程按照最差情况来估计

插入排序代码如下：

```java
public class InsertSort{
    
    public static void code_insertSort(int[] arr){
        
        if(arr == null || arr.length == 1){
            return;
        }
        
        for(int i = 1;i < arr.length;i++){
            for(int j = i;j > 0;j--){
                if(arr[j] < arr[j - 1]){
                    swap(arr,j,j - 1);
                }else{
                    break;
                }
            }
        }
    }
    
    public static void swap(int[] arr,int i,int j){
        arr[i] = arr[i] ^ arr[j];
        arr[j] = arr[i] ^ arr[j];
        arr[i] = arr[i] ^ arr[j];
    }
}
```

## 2.3 二分法的详解与扩展

1）在一个有序数组中，找某个数是否存在（找到就结束）

2）在一个有序数组中，找>=某个数最左侧的位置（二分到没有数停止）

3）局部最小值问题（数组arr，无序，相邻数一定不相等，找局部最小）

先单独判断0位置和N-1位置是不是局部最小，如果都不是，那么在0~N-1间必存在局部最小，使用二分法，取0~N-1中间位置M，若M位置不是局部最小，那么M-1位置的值小于M位置的值，继续在0~M-1上使用二分，一直二分到找到局部最小为止。

## 2.4 异或运算的性质与扩展

1）0^N=N    N^N=0

2）异或运算满足交换律和结合律

3）不用额外变量交换两个数（这两个数在内存中必须在不同的位置）

4）一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到这个数

5）一个数组种有两种数出现了奇数次，其他数都出现了偶数次，怎么找到这两个数



```java
public class BitCacul_1{
    public static void printOddTimesNum1(int[] arr){
        int eor = 0;
        for(int i = 0;i < arr.length;i++){
            eor ^= arr[i];
        }
        System.out.println("The num occurs odd times is " + eor);
    }
    
    public static void printOddTimesNum2(int[] arr){
        int eor = 0;
        for(int i = 0;i < arr.length;i++){
            eor ^= arr[i];
        }
        
        //eor=a^b
        //eor!=0
        //eor必有一位不为0!
        //找出eor最右边的1
        //onlyOne为a或者b（a或者b为数组中出现奇数次的数）
        int rightOne = eor & (~eor + 1);
        int onlyOne = 0;
        for(int i = 0;i < arr.length;i++){
            if(arr[i] & rightOne != 0){
                onlyOne ^= arr[i];
            }
        }
        
        System.out.println("One of the number occurs odd Times is " + onlyOne + ",the other is " + (eor ^ onlyOne));
        
    }
    
}
```

## 2.5 对数器的概念和使用

1，有一个你想要测的方法a

2，实现复杂度不好但是容易实现的方法b

3，实现一个随机样本产生器

4，把方法a和方法b跑相同的随机样本，看看得到的结果是否一样

5，如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a或者方法b

6，当样本数量很多时比对测试依然正确，可以确定方法a已经正确。

测试插入排序

准备一个方法b，生成一个随机数组

```java
public static void comparator(int[] arr){
    Arrays.sort(arr);
}


public static int[] generateRandomArray(int maxSize,int maxValue){
    
    //Math.random() -> [0,1),所有的小数,等概率返回一个(计算机里小数有穷尽)
    //Math.random() * N -> [0,N) 所有小数，等概率返回一个
    //(int) (Math.random() * N) [0,N-1]所有整数，等概率返回一个
    int[] arr = new int[(int)(Math.random() * (maxSize + 1))];
    for(int i = 0;i < arr.length;i++){
        arr[i] = (int)((maxValue + 1) * Math.random()) - (int)((maxValue + 1) * Math.random());
    }
    
    return arr;
    
}


public static int[] copyArray(int[] arr){
    int[] arr2 = new int[arr.length];
    for(int i = 0;i < arr.length;i++){
        arr2[i] = arr[i];
    }
    return arr2;
}

public static boolean isEqual(int[] arr1,int[] arr2){
    if(arr1 == null || arr2 == null || arr1.length != arr2.length){
        return false;
    }
    
    for(int i = 0;i < arr1.length;i++){
        if(arr1[i] != arr2[i]){
            return false;
        }
    }
    return true;
}


public static void main(String[] args){
    int testTime = 500000;
    int maxSize = 100;
    int maxValue = 100;
    boolean succeed = true;
    for(int i = 0;i < testTime;i++){
        int[] arr1 = generateRandomArray(maxSize,maxValue);
        int[] arr2 = copyArray(arr1);
        code_insertSort(arr1);//待测试方法
        comparator(arr2);//标准方法
        
        if(!isEqual(arr1,arr2)){
            succeed = false;
            break;
        }
    }
    
    System.out.println(succeed? "Nice!" : "Fucking fucked!");
}
```

# 3.递归

## 3.1剖析递归行为和递归行为复杂度的估算

用递归方法找一个数组中的最大值，系统上到底是怎么做的？

```java
public class RecruitFindMax{
    public static int getMax(int[] arr){
        return process(arr,0,arr.length - 1);
    }
    
    //[L...R]上求最大值
    public static int process(int[] arr,int L,int R){
        
        if(L == R){
            return arr[L];
        }
        
        int mid = L + ((R - L) >> 1);
        int leftMax = process(arr,L,mid);
        int rightMax = process(arr,mid + 1,R);
        return Math.max(leftMax,rightMax);
    }
}
```

## 3.2 master公式的使用

$$
T(N)=a*T(N/b)+O(N^d)
$$

母问题规模是N，子问题的规模是N/b，a是子问题的调用次数，O(N^d)是出去调用子问题之外剩下的过程，这样一类问题的递归可以使用master公式来求时间复杂度。

例如，上述递归求最大值，a为2，b为2，O(N^d)为O(1)
$$
T(N)=2*T(N/2)+O(1)
$$
对应时间复杂度：

1.log(b,a) > d  ->  时间复杂度为 O(N^log(b,a))

2.log(b,a) = d  ->  时间复杂度为 O(N^d * logN)

1.log(b,a) < d  ->  时间复杂度为 O(N^d)

对于上述递归求最大值，时间复杂度为O(N)，等效于遍历数组求最大值。

# 4 O(N*logN)的排序算法

## 4.1 归并排序

1）整体就是一个简单递归，左边排好序、右边排好序、让整体有序

2）让其整体有序的过程里用了外排序方法

3）利用master公式来求解时间复杂度

4）归并排序的实质

时间复杂度O(N*logN)，额外空间复杂度O(N)

```java
public class MergeSort{
    
    public static void mergeSort(int[] arr){
        if(arr.length == null || arr.length < 2){
            return;
        }
        process(arr,0,arr.length - 1);
    }
    
    public static void process(int[] arr,int L,int R){
        if(L == R){
            return;
        }
        int mid = L + ((R - L) >> 1);
        process(arr,L,mid);
        process(arr,mid + 1,R);
        merge(arr,L,mid,R);
    }
    
    public static void merge(int[] arr,int L,int M,int R){
        int[] help = new int[R - L + 1];
        int i = 0;
        int p1 = 0;
        int p2 = M + 1;
        while(p1 <= M && p2 <= R){
            help[i++] = arr[p1] <= arr[p2] ? arr[p1++]:arr[p2++];
        }
        
        while(p1 <= M){
            help[i++] = arr[p1++];
        }
        
        while(p2 <= R){
            help[i++] = arr[p2++];
        }
        
        for(int i = 0;i < help.length;i++){
            arr[L + i] = help[i];
        }
    }
}
```

使用master公式估计时间复杂度：a=2，b=2，d=1，因此log(b,a)=d,根据master公式计算时间复杂度为**O(N*logN)**，空间复杂度O(N)

为什么归并排序的时间复杂度可以是O(N*logN)，究竟归并排序做了什么使得时间复杂度由O(N^2)降为O(N*logN)？

归并排序的扩展

小和问题和逆序对问题

小和问题

在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。

例子：[1,3,4,2,5]1左边比1小的数，没有；3左边比3小的数，1；4左边比4小的数，1、3；2左边比2小的数，1；5左边比5小的数，1，3，4，2；所以小和为1+1+3+1+1+3+4+2=16

```java
public class SmallSum{
    public static int getSmallSum(int[] arr){
        if(arr == null || arr.length < 2){
            return 0;
        }
        return process(arr,0,arr.length - 1);
    }
    
    public static int process(int[] arr,int L,int R){
        if(L == R){
            return 0;
        }
        int mid = L + ((R - L) >> 1);
        
        return process(arr,L,mid) + process(arr,mid + 1,R) + 
            merge(arr,L,mid,R);        
    }
    
    public static int merge(int[] arr,int L,int M,int R){
        int[] help = new int[R - L + 1];
        int i = 0;
        int p1 = 0;
        int p2 = M + 1;
        int res = 0;
        while(p1 <= M && p2 <= R){
            res += arr[p1] < arr[p2]? (R - p2 + 1) * arr[p1]:0;
            help[i++] = arr[p1] < arr[p2]? arr[p1++]:arr[p2++];//(与归并排序不同，左组和右组相等时先拷贝右组数据)
        }
        
        while(p1 <= M){
            help[i++] = arr[p1++];
        }
        
        while(p2 <= R){
            help[i++] = arr[p2++];
        }
        
        for(int i = 0;i < help.length;i++){
            arr[L + i] = help[i];
        }
        
        return res;
    } 
}
```

逆序对问题 在一个数组中，左边的数如果比右边的数大，则这两个数构成一个逆序对，请打印所有逆序对。

与小和问题刚好相反

## 4.2 快速排序

荷兰国旗问题

问题一

给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N)

1）a[i]≤num，a[i]和≤区的下一个数交换，≤区右扩，i++；

2）a[i]＞num，i++；

问题二（荷兰国旗问题）

给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N)

1）a[i]<num，a[i]和<区的下一个数交换（**需要交换的原因：当i指向的值与num相等时，i++，当再次碰到a[i]<num时，就需要交换了**），<区右扩，i++；

2）a[i]=num，i++；

3）a[i]>num，a[i]和>区的前一个数交换，>区左扩，i原地不动；

快排1.0版本

以数组最后一个数x为基准，将≤x放数组左边，>x的数放数组右边，将基准x与＞区域的第一个数做交换，这样数组左边区域都是≤x的，数组右边区域都是＞x的，x的位置已固定下来，x左侧重复上述行为，x的右侧重复上述行为，最终整个数组有序。（对应问题一）

快排2.0版本

以数组最后一个数x为基准，将<x放数组左边，>x的数放数组右边，=x的数放中间，将基准x与＞区域的第一个数做交换，这样数组左边区域都是<x的，数组右边区域都是＞x的，数组中间区域都是=x的，一批x的位置已固定下来，x左侧重复上述行为，x的右侧重复上述行为，最终整个数组有序。（对应问题二）

这两个版本的时间复杂度为**O(N^2)**，例子：[1,2,3,4,5,6,7,8,9]。

快排3.0版本

随机选一个数与最后一个数做交换，重复快排1.0版本或者2.0版本。时间复杂度：求期望得出**O(N*logN)**。

快排的空间复杂度**：O(logN)**

```java
public class Code_QuickSort {
    public static void quickSort(int[] arr){
        if (arr == null || arr.length < 2){
            return;
        }
        quickSort(arr,0,arr.length - 1);
    }

    public static void quickSort(int[] arr,int L,int R){
        if(L >= R){
            return;
        }
        int index = (int)(Math.random() * (R - L + 1));
        swap(arr,L + index,R);
        int[] pos = partition(arr, L, R);
        quickSort(arr,L,pos[0]);
        quickSort(arr,pos[1],R);
    }


    public static int[] partition(int[] arr,int L,int R){

        //<区域边界
        int less = L - 1;
        //>区域边界
        int more = R;

        while(L < more){
            if (arr[L] < arr[R]){
                swap(arr,++less,L++);
            }else if(arr[L] > arr[R]){
                swap(arr,--more,L);
            }else{
                L++;
            }
        }
        swap(arr,more,R);

        return new int[]{less,more + 1};//一开始more为R，而非R+1
    }

    public static void swap(int[] arr,int i,int j){
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

}
```

## 4.3 堆排序

1.堆结构就是用数组实现的二叉树结构

2.完全二叉树中如果每棵子树的最大值都在顶部就是大根堆

3.完全二叉树中如果每棵子树的最小值都在顶部就是小根堆

4.堆结构的heapInsert和heapify操作

5.堆结构的增大和减少

6.优先级队列结构，就是堆结构

完全二叉树：一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。

堆排序代码如下：

```java
public class HeapSort {


    public static void main(String[] args) {
        int[] arr = new int[]{1,6,2,4,3,8,9,0,4,5,3,2,1};
        Arrays.sort(arr);
        System.out.println(Arrays.toString(arr));
        int[] arr1 = new int[]{1,6,2,4,3,8,9,0,4,5,3,2,1};
        heapSort(arr1);
        System.out.println(Arrays.toString(arr1));
    }

    public static void heapSort(int[] arr){
        if (arr == null || arr.length < 2){
            return;
        }

        //方法一：形成大根堆O(N*logN)
        for (int i = 0; i < arr.length; i++) {
            heapInsert(arr,i);
        }

        //方法二：使用heapify形成大根堆O(N)，错位相减法可证
        //for (int i = arr.length - 1; i >= 0; i--) {
            //heapify(arr,i,arr.length);
        //}

        int heapSize = arr.length;

        //最大值在0位置，将0位置的数与最后一位做交换
        while(heapSize > 0){
            heapify(arr,0,heapSize);
            swap(arr,0,--heapSize);
        }

    }

    //给定一个数，放入大根堆中，再次形成大根堆
    public static void heapInsert(int[] arr,int index){
        while(arr[index] > arr[(index - 1) / 2]){
            swap(arr,index,((index - 1)/ 2));
            index = (index - 1) / 2;
        }
    }

    public static void heapify(int[] arr,int index,int heapSize){
        int left = 2 * index + 1;

        while (left < heapSize){
            //求出孩子节点最大值的索引
            int largest = left + 1 < heapSize && arr[left + 1] > arr[left]? left + 1:left;

            //孩子节点最大值与父节点进行比较
            largest = arr[largest] > arr[index]? largest:index;


            if (largest == index){
                break;
            }

            swap(arr,index,largest);
            index = largest;//largest赋值给index，不赋值的话会影响20行
            left = 2 * index + 1;

        }

    }


    public static void swap(int[] arr,int i,int j){
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

题目：已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。

k=6，遍历数组前7个数（0~6），构造小根堆，小根堆的最小值（其实也是数组的最小值）在0位置，再遍历（1~7位置），构造小根堆， 小根堆顶的值就是1位置的值，以此类推。复杂度O(N*logk)

```java
public class Code_SortArrayDistanceLessK {

    public static void sortedArrDistanceLessK(int[] arr,int k){
        PriorityQueue<Integer> heap = new PriorityQueue<>();

        int index = 0;
        for (; index < Math.min(arr.length, k); index++) {
            heap.add(arr[index]);
        }

        int i = 0;
        for (; index < arr.length; i++,index++) {
            heap.add(arr[index]);
            arr[i] = heap.poll();
        }
        while (!heap.isEmpty()){
            arr[i++] = heap.poll();
        }
    }

}
```

## 4.4比较器的使用

1）比较器的实质就是重载比较运算符

2）比较器可以很好的应用在特殊标准的排序上

3）比较器可以很好的应用在根据特殊标准排序的结构上

实现Comparator接口，重写compare方法。

## 4.5桶排序思想下的排序

1）计数排序，基于词频数组排序

2）基数排序，基于位数的桶（按一个数各位上的数放入词频数组，先进先出，出桶入桶的次数等于最大数的位数）进行排序

分析：

1）桶排序思想下的排序都是不基于比较的排序

2）时间复杂度为O(N)，额外空间复杂度O(M)

3）应用范围有限，需要将样本的数据状况满足桶的划分

改进的基数排序算法（出桶入桶的过程由前缀和数组实现）：

```java
public class Code_RadixSort {

    public static void main(String[] args) {
        int[] arr = new int[]{5,4,3,2,7,9,1,0};

        radixSort(arr);

        System.out.println(Arrays.toString(arr));

    }


    public static void radixSort(int[] arr){
        if (arr == null || arr.length < 2){
            return;
        }
        radixSort(arr,0,arr.length - 1,maxbits(arr));
    }

    private static int maxbits(int[] arr) {

        int max = Integer.MIN_VALUE;
        for (int i = 0; i < arr.length; i++) {

            max = Math.max(max,arr[i]);
        }

        int res = 0;
        while (max != 0){
            res++;
            max = max / 10;
        }
        return res;
    }

    public static void radixSort(int[] arr,int L,int R,int digit){
        final int radix = 10;
        //有多少数就准备多少个辅助空间
        int[] bucket = new int[R - L + 1];
        int i = 0;
        int j = 0;
        for (int d = 1; d <= digit; d++) {//最大数有多少位就进出桶几次
            //准备一个词频数组
            //10个空间
            //count[0]当前位(d位)是0的数字有多少个
            //count[1]当前位(d位)是(0和1)的数字有多少个
            //count[2]当前位(d位)是(0、1和2)的数字有多少个
            //count[i]当前位(d位)是(0~i)的数字有多少个
            int[] count = new int[radix];
            for (i = L; i <= R; i++) {
                j = getDigit(arr[i],d);
                count[j]++;
            }

            //求前缀和
            for (i = 1; i < radix; i++) {
                count[i] = count[i - 1] + count[i];
            }

            //从右向左
            for (i = R;i >= L;i--){
                j = getDigit(arr[i],d);
                bucket[count[j] - 1] = arr[i];
                count[j]--;
            }

            for (i = L;i <=R; i++){
                arr[i] = bucket[i];
            }

        }
    }

    public static int getDigit(int x, int d) {

        return x / ((int)Math.pow(10,d - 1)) % 10;
    }
}
```

## 4.6排序算法的稳定性及其汇总

同样值的个体之间，如果不因为排序而改变相对次序，这个排序就是有稳定性的；否则就没有。

不具备稳定性的排序：

选择排序（交换时失去了稳定性）、快速排序（partion时失去了稳定性）、堆排序（调整为堆结构的过程破坏稳定性）

具备稳定性的排序：

冒泡排序（相邻两个数相等不进行交换就可以保证稳定性）、插入排序（遇到相等不进行交换就可以保证稳定性）、归并排序（merge时遇到相等的数先拷贝左边的数到辅助数组中）、一切桶排序思想下的排序（先入桶的先出桶保证稳定）

目前没有找到时间复杂度O(N*logN)，额外空间复杂度O(1)，又稳定的排序。

总结：

|   排序算法   | 时间复杂度 | 额外空间复杂度 | 稳定性 |
| :----------: | :--------: | :------------: | :----: |
|   选择排序   |   O(N^2)   |      O(1)      | 不稳定 |
|   冒泡排序   |   O(N^2)   |      O(1)      |  稳定  |
|   插入排序   |   O(N^2)   |      O(1)      |  稳定  |
|   归并排序   | O(N*logN)  |      O(N)      |  稳定  |
| 随机快速排序 | O(N*logN)  |    O(logN)     | 不稳定 |
|    堆排序    | O(N*logN)  |      O(1)      | 不稳定 |

通常选取快速排序，归并排序、随机快速排序 、堆排序的时间复杂度指标一样，但是快速排序的常数时间是最少的。

常见的坑

1.归并排序的额外空间复杂度可以变成O(1)，但是非常难，不需要掌握，有兴趣可以搜“归并排序 内部缓存法”，变完之后不再稳定。

2.”原地归并排序“的帖子都是垃圾，会让归并排序的时间复杂度变成O(N^2)。

3.快速排序可以做到稳定性问题，但是非常难，不需要掌握，可以搜”01 stable sort“，空间复杂度也会上升到O(N)。

4.所有的改进都不重要，因为目前没有找到时间复杂度O(N*logN)，额外空间复杂度O(1)，又稳定的算法。

5.有一道题目，是奇书放在数组左边，偶数放在数组右边，还要求原始的相对次序不变，碰到这个问题可以怼面试官。要求额外空间复杂度O(N)，时间复杂度O(N*logN)

工程上对排序的一些改进

1）充分利用O(N*logN)  和O(N^2)各自的优势，大样本快排，小样本插入

2）稳定性的考虑，Arrays.sort()方法基础类型快排，非基础类型归并排序，对于基础类型来说，稳定性指标无用，使用常数时间比较低的快排，非基础类型不确定需不需要稳定性，使用归并排序提供稳定性

# 5.哈希表和有序表

## 5.1哈希表的简单介绍

1）哈希表在使用层面上可以理解为一种集合结构

2）如果只有key，没有伴随数据value，可以使用HashSet结构(C++中叫UnOrderSet)

3）如果既有key，又有伴随数据value，可以使用HashMap结构(C++中叫UnOrderMap)

4）有无伴随数据value是HashSet和HashMap的唯一区别，底层的实际结构是一回事

5）使用哈希表增（put）、删（remove），改（put）和查（get）的操作，可以认为时间复杂度O(1)，但是常数时间比较大

6）放入哈希表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小

7）放入哈希表的东西，如果不是基础类型，内部按引用传递，内存占用就是这个东西内存地址的大小



有关哈希表的原理，将在提升班“与哈希函数有关的数据结构”一章中讲叙原理

## 5.2有序表的简单介绍

1）有序表在使用层面上可以理解为一种集合结构

2）如果只有key，没有伴随数据value，可以使用TreeSet结构(C++中叫OrderSet)

3）如果既有key，又有伴随数据value，可以使用TreeMap结构(C++中叫OrderMap)

4）有无伴随数据value是TreeSet和TreeMap的唯一区别，底层的实际结构是一回事

5）有序表和哈希表的区别是，有序表把key按照顺序组织起来，而哈希表完全不组织

6）红黑树、AVL树、size-balance-tree和跳表都属于有序表结构，只是底层具体实现不同

7）放入有序表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小

8）放入有序表的东西，如果不是基础类型，必须提供比较器，内部按引用传递，内存占用就是这个东西内存地址的大小

9）不管是什么底层具体实现，只要是有序表，都有以下固定的基本功能和固定的时间复杂度

有序表的固定操作

1）void put(K key,V value)：将一个(key,value)记录加入到表中，或者将key的记录更新成value

2）V get(K key)：根据给定的key，查询value并返回

3）void remove(K key)：移除key的记录

4）boolean containsKey(K key)：询问是否有关于key的记录

5）K firstKey()：返回所有键值的排序结果中，最左边那个

6）K lastKey()：返回所有键值的排序结果中，最右边那个

7）K floorKey(K key)：如果表中存入过key，则返回key；否则，返回所有键值的排序结果中，key的前面一个

8）K ceilingKey(K key)：如果表中存入过key，则返回key；否则，返回所有键值的排序结果中，key的后面一个

以上所有操作的时间复杂度都是O(logN)，N为有序表含有的记录数

# 6.单链表和双链表

单链表的节点结构

```java
class Node<V>{
    V value;
    Node next;
}
```

由以上结构的节点依次连接起来所形成的链叫单链表结构。

双链表的节点结构

```java
class Node<V>{
    V value;
    Node next;
    Node last;
}
```

由以上结构的节点依次连接起来所形成的链叫双链表结构。

单链表和双链表结构只需要给定一个头部节点head，就可以找到剩下的所有的节点。

反转单向和双向链表

【题目】 分别实现反转单向链表和反转双向链表的函数

【要求】如果链表长度为N，时间复杂度要求为O(N)，额外空间复杂度要求为O(1)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null){
            return head;
        }
        ListNode curHead = reverseList(head.next);
        ListNode curNext = head.next;
        head.next = null;
        curNext.next = head;
        return curHead;
    }
}
```



打印两个有序链表的公共部分

【题目】给定两个有序链表的头指针head1和head2，打印两个链表的公共部分

【要求】如果两个链表的长度之和为N，时间复杂度要求为O(N)，额外空间复杂度要求为O(1)

类似于归并排序外排的过程

面试时链表解题的方法论

1）对于笔试，不用太在乎空间复杂度，一切为了时间复杂度

2）对于面试，时间复杂度依然放在第一位，但是一定要找到空间最省的方法

重要技巧：

1）额外数据结构记录（哈希表等）

2）快慢指针

判断一个链表是否是回文结构

【题目】给定一个单链表的头节点head，请判断该链表是否为回文结构。

【例子】 1->2->1，返回true；1->2->2->1，返回true；15->6->15，返回true；

1->2->3，返回false，

【要求】如果链表长度为N，时间复杂度要求为O(N)，额外空间复杂度要求为O(1)

方法一：基于数据结构栈

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        if (head == null){
            return false;
        }
        ListNode cur = head;
        Stack<ListNode> stack = new Stack<>();
        while (cur != null){
            stack.push(cur);
            cur = cur.next;
        }

        while (head != null){
            if (head.val != stack.pop().val){
                return false;
            }
            head = head.next;
        }
        return true;
    }
}
```

方法二：基于O(n/2)的额外空间复杂度

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null){
            return true;
        }


        Stack<ListNode> stack = new Stack<>();


        ListNode slow = head;
        ListNode fast = head;

        while(fast.next != null && fast.next.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }

        slow = slow.next;

        while (slow != null){
            stack.push(slow);
            slow = slow.next;
        }

        while (!stack.isEmpty()){
            if (stack.pop().val != head.val){
                return false;
            }
            head = head.next;
        }

        return true;
    }
}
```

方法三：基于有限几个变量实现回文链表判断

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null){
            return true;
        }


        ListNode slow = head;
        ListNode fast = head;

        while(fast.next != null && fast.next.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }
        //此时slow指向mid
        fast = slow.next;//fast记录mid的下一位
        slow.next = null;//mid指向null


        //完成逆序
        while (fast != null){
            ListNode temp = fast.next;
            fast.next = slow;//逆序链表
            slow = fast;
            fast = temp;
        }

        //slow指向最后一位，head指向第一位
        //使用变量记录最后一位，方便恢复链表
        ListNode tail = slow;
        fast = head;
        while (fast != null && slow != null){
            if (fast.val != slow.val){
                return false;
            }
            fast = fast.next;
            slow = slow.next;
        }

        //恢复链表
        fast = tail.next;
        tail.next = null;
        while (fast != null){
            ListNode temp = fast.next;
            fast.next = tail;
            tail = fast;
            fast = temp;
        }

        return true;
    }
}
```

【题目】给定一个单链表的头节点head，节点的值类型是整型，再给定一个证书pivot。实现一个调整链表的函数，将链表调整为左部分都是小于pivot的节点，中间部分都是值等于pivot的节点，右部分都是值大于pivot的节点。

方法一：基于数组，类似快排做partition

```java
public class Solution {

    public static ListNode listPartition1(ListNode head,int pivot){
        if (head == null){
            return head;
        }

        ListNode cur = head;
        int i = 0;
        while (cur != null){
            i++;
            cur = cur.next;
        }

        ListNode[] nodeArr = new ListNode[i];
        i = 0;
        cur = head;
        for (i = 0; i < nodeArr.length; i++) {
            nodeArr[i] = cur;
            cur = cur.next;
        }
        arrPartition(nodeArr,pivot);
        for (i = 0; i < nodeArr.length - 1; i++) {
            nodeArr[i].next = nodeArr[i + 1];
        }
        
        nodeArr[i].next = null;
        
        return nodeArr[0];
        
    }

    public static void arrPartition(ListNode[] nodeArr,int pivot){
        int less = -1;
        int more = nodeArr.length;
        int index = 0;
        while (index != more){
            if (nodeArr[index].val < pivot){
                swap(nodeArr,index++,++less);
            }else if (nodeArr[index].val == pivot){
                index++;
            }else{
                swap(nodeArr,index,--more);
            }
        }
    }


    public static void swap(ListNode[] nodeArr,int i,int j){
        ListNode temp = nodeArr[i];
        nodeArr[i] = nodeArr[j];
        nodeArr[j] = temp;
    }

}
```

方法二：基于有限几个变量实现

【进阶】在实现原问题功能的基础上增加如下的要求

【要求】调整后所有小于pivot的节点之间的相对顺序和调整前一样

【要求】调整后所有等于pivot的节点之间的相对顺序和调整前一样

【要求】调整后所有大于pivot的节点之间的相对顺序和调整前一样

【要求】时间复杂度达到O(N)，额外空间复杂度达到O(1)

【题目】一种特殊的单链表节点类描述如下

```java
class ListNode{
    int val;
    ListNode next;
    ListNode rand;
    ListNode(int val){
        this.val = val;
    }
}
```

```java
public class Solution {

    public static ListNode listPartition2(ListNode head,int pivot){

        ListNode SH = null;//小于部分头结点
        ListNode ST = null;//小于部分尾结点
        ListNode EH = null;//等于部分头结点
        ListNode ET = null;//等于部分尾结点
        ListNode BH = null;//大于部分头结点
        ListNode BT = null;//大于部分尾结点


        while (head != null){

            if (head.val < pivot){
                if (SH == null){
                    SH = head;
                    ST = head;
                }else{
                    ST.next = head;
                    ST = head;
                }
            }else if (head.val == pivot){
                if (EH == null){
                    EH = head;
                    ET = head;
                }else{
                    ET.next = head;
                    ET = head;
                }
            }else{
                if (BH == null){
                    BH = head;
                    BT = head;
                }else{
                    BT.next = head;
                    BT = head;
                }
            }
            head = head.next;

        }


        if (ST != null){
            ST.next = EH;
            ET = ET == null? ST:ET;
        }

        if (ET != null){
            ET.next = BH;
            BT = BT == null? ET:BT;
        }

        if (BT != null){
            BT.next = null;
        }

        return SH != null? SH:(EH != null? EH:BH);


    }

}
```

【题目】rand指针是单链表节点结构中新增的指针，rand可能指向链表中的任意一个节点，也可能指向null。给定一个由ListNode节点类型组成的无环单链表的头节点head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。

【要求】时间复杂度O(N)，额外空间复杂度O(1)

方法一：基于Map集合，但额外空间复杂度为O(N)

```java
import java.util.HashMap;
import java.util.Map;

class Solution {
    public Node copyRandomList(Node head) {
        
        if (head == null){
            return head;
        }
        
        Node cur = head;
        Map<Node,Node> map = new HashMap<>();

        while(cur != null){
            map.put(cur,new Node(cur.val));
            cur = cur.next;
        }

        cur = head;

        while (cur != null){

            map.get(cur).next = map.get(cur.next);
            map.get(cur).random = map.get(cur.random);
            cur = cur.next;
        }

        return map.get(head);
    }
}
```

方法二：基于链表拼接方法,额外空间复杂度O(1)

```java
class Solution {
    public Node copyRandomList(Node head) {

        if (head == null){
            return head;
        }
		
        //拼接链表1->1'->2->2'->3->3'
        Node cur = head;
        Node nextCopy = null;
        while (cur != null){
            nextCopy = cur.next;
            cur.next = new Node(cur.val);
            cur.next.next = nextCopy;
            cur = nextCopy;
        }

        cur = head;
		//设置copy链表的random指针
        while (cur != null){
            nextCopy = cur.next;
            if (cur.random != null){
                nextCopy.random = cur.random.next;
            }
            cur = nextCopy.next;
        }
		
        //拆分链表
        cur = head;
        //需要在开头判空
        Node res = head.next;
        Node nextSelf = null;
        while (cur != null){
            nextCopy = cur.next;
            nextSelf = cur.next.next;
            cur.next = nextSelf;

            if (nextSelf != null){
                nextCopy.next = nextSelf.next;
            }

            cur = nextSelf;
        }

        return res;
    }
}
```

【题目】给定两个可能有环也可能无环的单链表，头节点head1和head2。请实现一个函数，如果两个链表相交，请返回相交的第一个节点。如果不相交，返回null。

【要求】如果两个链表长度之和为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)。

```java
public class Solution {

    //综合考虑
    public static Node findFirstIntersectionNode(Node head1,Node head2){
        if (head1 == null || head2 == null){
            return null;
        }

        Node loop1 = getLoopNode(head1);
        Node loop2 = getLoopNode(head2);

        if (loop1 == null && loop2 == null){
            return noLoop(head1,head2);
        }

        if (loop1 != null && loop2 != null){
            return bothLoop(head1,loop1,head2,loop2);
        }
        
        return null;

    }



    //找到链表的第一个入环节点，如果无环返回null
    public static Node getLoopNode(Node head){
        //快慢指针
        if (head == null || head.next == null || head.next.next == null){
            return null;
        }

        Node fast = head.next.next;
        Node slow = head.next;

        while (fast != slow){
            if (fast.next == null || fast.next.next == null){
                return null;
            }
            slow = slow.next;
            fast = fast.next.next;
        }

        fast = head;

        while (fast != slow){

            fast = fast.next;
            slow = slow.next;
        }

        return fast;
    }


    //两个无环链表相交，从某一节点开始全都共用节点
    //如果两个链表都无环，返回第一个相交节点，如果不相交，返回null
    public static Node noLoop(Node head1,Node head2){
        Node cur1 = head1;
        Node cur2 = head2;
        int n = 0;

        while (cur1 != null){
            n++;
            cur1 = cur1.next;
        }

        while (cur2 != null){
            n--;
            cur2 = cur2.next;
        }

        if (cur1 != cur2){
            return null;
        }

        //n为两链表长度的差值
        cur1 = n > 0? head1:head2;
        cur2 = cur1 == head1? head2:head2;

        n = Math.abs(n);
        while (n != 0){
            cur1 = cur1.next;
            n--;
        }

        while (cur1 != cur2){
            cur1 = cur1.next;
            cur2 = cur2.next;
        }
        return cur1;
    }

    //一个链表无环，一个链表有环，不可能相交
    //两个链表都有环,1)不相交，2）共用入环节点 3）入环节点不相同
    public static Node bothLoop(Node head1,Node loop1,Node head2,Node loop2){

        if (loop1 == loop2){
            //情况2，将loop1当作结束节点，使用noLoop方法求第一个共用节点
            Node cur1 = head1;
            Node cur2 = head2;
            int n = 0;
            while (cur1 != loop1){
                n++;
                cur1 = cur1.next;
            }

            while (cur2 != loop2){
                n--;
                cur2 = cur2.next;
            }

            cur1 = n > 0? head1:head2;
            cur2 = cur1 == head1? head2:head1;

            n = Math.abs(n);

            while (n != 0){
                n--;
                cur1 = cur1.next;
            }

            while (cur1 != cur2){
                cur1 = cur1.next;
                cur2 = cur2.next;
            }
            return cur1;

        }else{
            //情况1和3，让loop1继续前进，如果遇到loop2则返回loop1/loop2
            //如果未遇到loop2则返回null
            Node temp = loop1.next;
            while (temp != loop1){
                if (temp == loop2){
                    return loop1;
                }
            }
            return null;

        }

    }
}
```

# 7.二叉树

## 7.1二叉树节点结构

```java
class Node<V>{
    V value;
    Node left;
    Node right;
}
```

用递归和非递归两种方式实现二叉树的先序、中序和后续遍历

如何直观的打印一棵二叉树

如何完成二叉树的宽度优先遍历（常见题目：求一棵二叉树的宽度）

## 7.2先序遍历、中序遍历和后序遍历

对于二叉树：[1,2,3,4,5,6,7]，递归序：1,2,4,4,4,2,5,5,5,2,1,3,6,6,6,3,7,7,7,3,1

先序遍历：对于每一棵树或者子树，都是按头节点、左节点、右节点的顺序遍历。对应递归序，就是打印第一次遇到的节点。

中序遍历：对于每一棵树或者子树，都是按左节点、头节点、右节点的顺序遍历。对应递归序，就是打印第二次遇到的节点。

后序遍历：对于每一棵树或者子树，都是按左节点、右节点、头节点的顺序遍历。对应递归序，就是打印第三次遇到的节点。

代码：

```java
public class Solution{
    
    //递归先序遍历
    public static void preOrderRecur(Node head){
        if(head == null){
            return;
        }
        //第一次来到节点打印
        System.out.print(head.value + " ");
        preOrderRecur(head.left);
        preOrderRecur(head.right);
    }
    //递归中序遍历
    public static void inOrderRecur(Node head){
        if(head == null){
            return;
        }
        preOrderRecur(head.left);
        //第二次来到节点打印
        System.out.print(head.value + " ");
        preOrderRecur(head.right);
    }
    //递归中序遍历
    public static void posOrderRecur(Node head){
        if(head == null){
            return;
        }
        preOrderRecur(head.left);
        preOrderRecur(head.right);
        //第三次来到节点打印
        System.out.print(head.value + " ");
    }
    
    //非递归先序遍历
    //准备一个栈，1）从栈中弹出一个节点，2）打印，3）先右再左压栈（如果有）
    public static void preOrderUnRecur(Node head){
        if(head == null){
            return;
        }
        
        Stack<Node> stack = new Stack<>();
		stack.push(head);       
        while(!stack.isEmpty()){
            head = stack.pop();
            System.out.print(head.value + " ");
            if(head.right != null){
                stack.push(head.right);
            }
            if(head.left != null){
                stack.push(head.left);
            }
            
        }
    }
    
    //非递归中序遍历
    //准备一个栈
    public static void inOrderUnRecur(Node head){
        if(head == null){
            return;
        }
        
        Stack<Node> stack = new Stack<>();
        while(!stack.isEmpty() || head != null){
            
            if(head != null){
                stack.push(head);
                head = head.left;
            }else{
                head = stack.pop();
                System.out.print(head.value + " ");
                head = head.right;
            }
            
        }
        System.out.println();
    }
    
    //非递归后序遍历
    //准备一个栈和一个收集栈
    public static void inOrderUnRecur(Node head){
        if(head == null){
            return;
        }
        
        Stack<Node> stack1 = new Stack<>();
        Stack<Node> stack2 = new Stack<>();
        //头右左进入收集栈
        stack1.push(head);
        while(!stack1.isEmpty()){
            Node cur = stack1.pop();
            stack2.push(cur);
            if(cur.left != null){
                stack.push(cur.right);
            }
            if(cur.right != null){
                stack.push(cur.left);
            }
            
        }
        //出栈顺序：左右头
        while(!stack2.isEmpty()){
            System.out.print(stack.pop().value + " ");
        }
        System.out.println();
    }
    
}
```

## 7.3 直观打印二叉树

代码：

```Java
class Node{
    int value;
    Node left;
    Node right;
    
    Node(int value){
        this.value = value;
    }
}

public class BinaryTree{
    public static void printTree(Node head){
        System.out.println("Binary Tree:");
        printInOrder(head,0,"H",17);
        System.out.println();
    }
    
    public static void printInOrder(Node head,int height,String to,int len){
        if(head == null){
            return;
        }
        
        printInOrder(head.right,height + 1,"v",len);
        String val = to + head.value + to;
        int lenM = val.length();
        int lenL = (len - lenM) / 2;
        int lenR = len - lenM -lenL;
        val = getSpace(lenL) + val + getSpace(lenR);
        System.out.println(getSpace(height * len) + val);
        printInOrder(head.left,height + 1,"^",len);
    }
    
    public static String getSpace(int num){
        String space = " ";
        StringBuffer buf = new StringBuffer("");
        for(int i = 0;i < num;i++){
            buf.append(space);
        }
        return buf.toString();
    }
}
```

## 7.4二叉树的宽度优先遍历

```java
class Solution{
    public static void width(Node head){
        if(head == null){
            return;
        }
        
        Queue<Node> queue = new LinkedList<>();
        queue.add(head);
        while(!queue.isEmpty()){
            Node cur = queue.poll();
            System.out.println(cur.value);
            if(cur.left != null){
                queue.add(cur.left);
            }
            if(cur.right != null){
                queue.add(cur.right);
            }
        }
    }
}
```

常见题目：求一棵二叉树的宽度。

【分析】：当前层是第几层，当前层有几个节点，当前层的节点数是不是最多的

```java
class Solution{
    public static int getWidth(Node head){
        
        if(head == null){
            return 0;
        }
        
        Queue<Node> queue = new LinkedList<>();
        Map<Node,Integer> map = new HashMap<();
        queue.add(head);
        map.put(head,1);
        int curLevelNodeCount = 0;
        int curLevel = 1;
        int max = Integer.MIN_VALUE;//已遍历过的层中的最大节点数
        
        while(!queue.isEmpty()){
            Node cur = queue.poll();
            if(map.get(cur) == curLevel){
                curLevelNodeCount++;
            }else{
                max = Math.max(curLevelNodeCount,max);
                curLevelNodeCount = 1;
                curLevel++;
            }
            if(cur.left != null){
                queue.add(cur.left);
                map.put(cur.left,curLevel + 1);
            }
            
            if(cur.right != null){
                queue.add(cur.right);
                map.put(cur.right,curLevel + 1);
            }
            
        }
        return max;
        
    }
}
```

有限几个变量实现

```java
class Solution{
    public static int getWidth(Node head){
        if(head == null){
            return 0;
        }
        
        Queue<Node> queue = new LinkedList<>();
        queue.add(head);
        Node curLevelEnd = head; //当前层最后一个节点
        Node nextLevelEnd = null;//下一层最后一个节点
        
        int max = Integer.MIN_VALUE;
        int curLevelNodeCount = 0;
        
        while(!queue.isEmpty()){
            Node cur = queue.poll();
            curLevelNodeCount++;
            if(cur == curLevelEnd){
                max = Math.max(max,curLevelNodeCount);
                curLevelNodeCount = 0;
                curLevelEnd = nextLevelEnd;
                nextLevelEnd = null;
            }
            
            if(cur.left != null){
                queue.add(cur.left);
                nextLevelEnd = cur.left;
            }
            
            if(cur.right != null){
                queue.add(cur.right);
                nextLevelEnd = cur.right;
            }
        }
        
        return max;
        
        
    }
}
```

## 7.5 二叉树的相关概念及其实现判断

如何判断一棵二叉树是否是搜索二叉树？

中序遍历

```java
public class TestBST{
    
    public static class Node{
        public int value;
        public Node left;
        public Node right;
    }
    
    public static int preValue = Integer.MIN_VALUE;
    
    public static boolean isBSTRecur(Node head){
        if(head == null){
             return true;
        }
        boolean isLeftBst = isBSTRecur(head.left);
        //左子树不是搜索二叉树
        if(!isLeftBst){
            return false;
        }
        //
        if(head.value <= preValue){
            return false;
        }
        return isBSTRecur(head.right);
    }
    
    public static boolean inOrderUnRecur(Node head){
        if(head != null){
            Stack<Node> stack = new Stack<>();
            while(head != null || !stack.isEmpty()){
                if(head != null){
                    stack.push(head);
                    head = head.left;
                }else{
                    head = stack.pop();
                    if(preValue >= head.value){
                        return false;
                    }else{
                        preValue = head.value;
                    }
                    head = head.right;
                }
            }
        }
        
        return true;
    }
    
}
```

递归套路实现判断一棵二叉树是否是搜索二叉树

```java
public class Soution{
    public static class Node{
        public int value;
        public Node left;
        public Node right;
        
        public Node(int value){
            this.value = value;
        }
    }
    
    public static class ReturnType{
        public boolean isBST;
        public int max;
        public int min;
        
        public ReturnStruct(boolean isBST,int max,int min){
            this.isBST = isBST;
            this.max = max;
            this.min = min;
        }
        
        public static boolean isBSTMethod(Node head){
            if(head == null){
                return true;
            }
            
            
        }
        
        public static ReturnType process(Node x){
            if(x == null){
                return null;
            }
            
            ReturnType leftData = process(x.left);
            ReturnType rightData = process(x.right);
            int min = x.value;
            int max = x.value;
            if(leftData != null){
                min = Math.min(leftData.min,min);
                max = Math.max(leftData.max,max);
            }
            if(rightData != null){
                min = Math.min(rightData.min,min);
                max = Math.max(rightData.max,max);
            }
            
            boolean isBST = true;
            
            if(leftData != null && (!leftData.isBalanced || x.value < leftData.max)){
                isBST = false;
            }
            
            if(rightData != null && (!rightData.isBalanced || x.value > rightData.min)){
                isBST = false;
            }
            
            return new ReturnType(isBST,max,min);
        }
        
    }
}
```

如何判断一棵二叉树是否是完全二叉树？

```java
/**
宽度遍历：
1)任一节点，有右无左，直接返回false
2）满足第一种情况，任一节点的左右节点不双全，接下来的每个节点必须是叶子节点
*/

public class Solution{
    public static class Node{
        public int value;
        public Node left;
        public Node right;
        
        public Node(int value){
            this.value = value;
        }
        
    } 
   
    public static boolean isCBT(Node head){
        if(head == null){
            return true;
        }
        
        boolean leaf = false;
        
        Queue<Node> queue = new LinkedList<>();
        queue.add(head);
        
        while(!queue.isEmpty()){
            head = queue.poll();
            
            if(head.right != null && head.left == null
              	||
              	leaf && (head.left != null || head.right != null)
              ){
                return false;
            }
            
            if(head.left != null){
                queue.add(head.left);
            }
            
            if(head.right != null){
                queue.add(head.right);
            }
            
            if(head.left != null || head.right != null){
                leaf = true;
            }
            
            
        }
        
        return true;
        
    }
    
    
}
```

如何判断一棵二叉树是否是满二叉树？

```java
/**
根据二叉树的高度和节点个数判断是否是满二叉树
*/

public class Solution{
    public static class Node{
        public int value;
        public Node left;
        public Node right;
       
        public Node(int value){
            this.value = value;
        } 
    }
    
    public static class ReturnType{
        public int height;
        public int nodes;
        
        public ReturnType(int height,int nodes){
            this.height = height;
            this.nodes = nodes;
        }
    }
    
    
    public static boolean isFullBT(Node head){
        
        if(head == null){
            return true;
        }
        
        ReturnType data = process(head);
        return data.nodes == (1 << data.height - 1);
        
        
    }
    
    
    public static ReturnType process(Node x){
        if(x == null){
            return new ReturnType(0,0);
        }
        
        ReturnType leftData = process(x.left);
        ReturnType rightData = process(x.right);
        
        int height = Math.max(leftData.height,rightData.height) + 1;
        int nodes = leftData.nodes + rightData.nodes + 1;
        
        return new ReturnType(height,nodes);
        
    }
    
    
}

```

如何判断一棵二叉树是否是平衡二叉树？（二叉树题目套路）

```java
public class Solution{
    public static class Node{
        public int value;
        public Node left;
        public Node right;

        public Node(int value){
            this.value = value;
        } 
    }
    
    public static class ReturnType{
        public boolean isBalanced;
        public int height;
        
        
        public ReturnType(boolean isBalanced,int height){
            this.isBalanced = isBalanced;
            this.height = height;
        }
        
        public static boolean isBalancedTree(Node head){
            if(head == null){
                return true;
            }
            
            ReturnType data = process(head);
            
            return data.isBalanced;
            
        }
        
        public static ReturnType process(Node x){
            if(x == null){
                return new ReturnType(true,0);
            }
            
            ReturnType leftData = process(x.left);
            ReturnType rightData = process(x.right);
            
            int height = Math.max(leftData.height,rightData.height) + 1;
            boolean isBalanced = leftData.isBalanced && rightData.isBalanced && 
                Math.abs(leftData.height - rightData.height) < 2;
            
            return new ReturnType(isBalanced,height);
        }
        
        
    }
    
    
}
```

给定二叉树的两个节点node1和node2，找到他们的最低公共祖先节点。

```java
/**

1）o1是o2的lca或者o2是o1的lca
2）o1和o2不互为lca，向上才能找到

*/
public class Solution{
    public static class Node{
        public int value;
        public Node left;
        public Node right;
        
        public Node(int value){
            this.value = value;
        }
    }
    
    public static Node lca(Node head,Node o1,Node o2){
        Map<Node node> fatherMap = new HashMap<>();
        fatherMap.put(head,head);
        process(fatherMap,head);
        
        Set<Node> set1 = new HashSet<>();
        Node cur = o1;
        while(cur != fatherMap.get(cur)){
            set1.add(cur);
            cur = fatherMap.get(cur);
        }
        
        set1.add(head);
        Node cur = o2;
        while(cur != fatherMap.get(cur)){
            if(set1.contains(cur)){
                return cur;
            }
            cur = fatherMap.get(cur);
        }
        
        return head;
        
        
    }
    
    public static void process(Map<Node,Node> fatherMap,Node head){
        if(head == null){
            return;
        }
        
        if(head.left != null){
            fatherMap.put(head.left,head);
        }
        if(head.right != null){
            fatherMap.put(head.right,head);
        }
        process(fatherMap,head.left);
        process(fatherMap,head.right);
        
    }
    
    
}
```

```java
public class Solution{
    public static class Node{
        public int value;
        public Node left;
        public Node right;
        
        public Node(int value){
            this.value = value;
        }
    }
    
	
    public static Node lca(Node head,Node o1,Node o2){
        if(head == null || head == o1 || head == o2){
            return head;
        }
        
        Node left = lca(head.left,o1,o2);
        Node right = lca(head.right,o1,o2);
        
        if(left != null && right != null){
            return head;
        }
        
        return left != null? left:right;
        
        
    }
    

    
    
}
```

在二叉树中找到一个节点的后继节点

【题目】现在有一种新的二叉树节点类型如下：

```java
public class Node{
    public int value;
    public Node left;
    public Node right;
    public Node parent;
     
    public Node(int value){
        this.value = value;
    }
}
```

该结构比普通二叉树节点结构多了一个指向父节点的parent指针。

假设有一棵Node节点类型组成的二叉树，树中每个节点的parent指针都正确地指向自己的父节点，头节点地parent指向null。

只给一个在二叉树中的某个节点node，请实现返回node的后继节点的函数。

在二叉树的中序遍历的序列中，node的下一个节点叫做node的后继节点。

```java
/**
1）当前节点有右子树，求右子树的最左节点
2）当前节点没有右子树，一直向上找，直到发现当前节点是其父节点的左节点

*/
public class Solution{
    public static Node getSuccessorNode(Node node){
        if(node == null){
            return null;
        }
        
        if(node.right != null){
            return getMostLeft(node.right);
        }else{
            while(node.parent != null && node.parent.left != node){
                node = node.parent;
            }
            return node.parent;
        }
        
    }
    
    public static Node getMostLeft(Node node){
        if(node == null){
            return null;
        }
        while(node.left != null){
            node = node.left;
        }
        return node;
    }
}
```

二叉树的序列化和反序列化

就是内存里的一棵树如何变成字符串形式，又如何从字符串形式变成内存里的一棵树

```java
public class Solution{
    public class Node{
        public int value;
        public Node left;
        public Node right;

        public Node(int value){
            this.value = value;
        }
	}
    
    public static String serialByPre(Node head){
        if(head == null){
            return "#_";
        }
        
        String res = head.value + "_";
        res += serialByPre(head.left) + serialByPre(head.right);
        
        return res;
    }
    
    public static Node reconByPreString(String preStr){
        String[] value = preStr.split("_");
        Queue<String> queue = new LinkedList<>();
        for(i = 0;i < value.length;i++){
            queue.add(value[i]);
        }
        
        return reconByPreOrder(queue);
        
    }
    
    
    public static Node reconByPreOrder(Queue<String> queue){
        String value = queue.poll();
        
        if("#".equals(value)){
            return null;
        }
        
        Node head = new Node(Integer.valueOf(value));
        
        head.left = reconByPreOrder(queue);
        head.right = reconByPreOrder(queue);
        
        
        return head;
    }
    
    
}
```

折纸问题

请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折一次，压出折痕后展开。

此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。

如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕、上折痕。

给定一个输入参数N，代表纸条都从下边向上方连续对折N次。

请从上到下打印所有折痕的方向。

例如：N=1时，打印：down N=2时，打印：down down up

```java
public class Solution{
    public static void printAllFolds(int N){
        printProcess(1,N,true);
    }
    
    public static void printProcess(int i,int N,boolean down){
        if(i > N){
            return;
        }
        
        printProcess(i + 1,N,true);
        System.out.print(down? "凹":"凸");
        printProcess(i + 1,N,false);
    }
    
}
```

如何判断一棵二叉树是不是另一棵二叉树的子树？

```java
public class Solution{
    public class Node{
        public int value;
        public Node left;
        public Node right;

        public Node(int value){
            this.value = value;
        }
    }
    
    //判断head2为头节点的树是否是head1为头节点的树的子树
    public static boolean isSubStruct(Node head1,Node head2){
        boolean result = false;
        if(head1 != null && head2 != null){
            if(head1.value == head2.value){
                result = doesTree1HasTree2(head1,head2)
            }
            if(!result){
                result = isSubStruct(head1.left,head2);
            }
            if(!result){
                result = isSubStruct(head1.right,head2);
            }
        }
        
        return result;
    }
    
    public static boolean doesTree1HasTree2(Node head1,Node head2){
        
        //只看head2左右子树是否还有内容
        if(head2 == null){
            return true;
        }
        
        //head2!=Nnull
        if(head1 == null){
            return false;
        }
        
        if(head1.value != head2.value){
            return false;
        }
        
        return doesTree1HasTree2(head1.left,head2.left) &&
        doesTree1HasTree2(head1.right,head2.right);
        
    }
    
}
```

# 8.图

## 8.1图的存储方式

图的存储方式

1）邻接表

2）邻接矩阵

如何表达图？生成图？

```java
public class Graph{
    public Map<Integer,Node> nodes;
    public Set<Edge> edges;
    
    public Graph(){
        nodes = new HashMap<>();
        edges = new HashSet<>();
    }
    
}
```

```java
public class Node{
    public int value;
    public int in;
    public int out;
    public List<Node> nexts;
    List<Edge> edges;
    
    public Node(int value){
        this.value = value;
        in = 0;
        out = 0;
        nexts = new ArrayList<>();
        edges = new ArrayList<>();
    }
    
}
```

```java
public class Edge{
    public int weight;
    public Node from;
    public Node to;
   
    public Edge(int weight,Node from,Node to){
        this.weight = weight;
        this.from = from;
        this.to = to;
    }
}
```

```java
public class Solution{
    /**
     N*3的矩阵
     [from节点值,to节点值,weight]
    */
    public static Graph createGraph(Integer[][] matrix){
        Graph graph = new Graph();
        for(int i = 0;i < matrix.length;i++){
            //先对Node加工
            Integer from = matrix[i][0];
            Integer to = matrix[i][1];
            Integer weight = matrix[i][2];
            
            if(!graph.nodes.containsKey(from)){
                graph.nodes.put(from,new Node(from));
            }
            
            if(!graph.nodes.containsKey(to)){
                graph.nodes.put(to,new Node(to));
            }
            
            Node fromNode = graph.nodes.get(from);
            Node toNode = graph.nodes.get(to);
            
            //每条边只会出现一次
            Edge newEdge = new Edge(weight,fromNode,toNode);
            
            fromNode.nexts.add(toNode);
            fromNode.out++;
            fromNode.edges.add(newEdge)
            toNode.in++;
            graph.edges.add(newEdge);
        }
    }
}
```

## 8.2图的遍历

宽度优先遍历

1.利用队列实现

2.从源节点开始依次按照宽度进队列，然后弹出

3.每弹出一个节点，把该节点所有没进过队列的邻接点放入队列

4.直到队列变空

深度优先遍历

1.利用栈实现

2.从源节点开始把节点按照深度放入栈，然后弹出

3.每弹出一个点，把该节点下一个没有进过栈的邻接点放入栈

4.直到栈变空

```java
public class Solution{
    public static bfs(Node node){
        if(node == null){
            return;
        }
        
        Queue<Node> queue = new LinkedList<>();
        Set<Node> set = new HashSet<>();
        queue.add(node);
        set.add(node);
        
        while(!queue.isEmpty()){
            Node cur = queue.poll();
            System.out.println(cur.value);
            for(Node next : cur.nexts){
                if(!set.contains(next)){
                    set.add(next);
                    queue.add(next);
                }
            }
            
        }
    }
    
    public static void dfs(Node node){
        if(node == null){
            return;
        }
        
        Stack<Node> stack = new Stack<>();
        Set<Node> set = new HashSet<>();
        stack.push(node);
        set.add(node);
        System.out.println(node.value);
        while(!statck.isEmpty()){
            Node cur = stack.pop();
            for(Node next : node.nexts){
                if(!set.contains(next)){
                    stack.push(cur);
                    stack.push(next);
                    set.add(next);
                    System.out.println(next.value);
                    break;
                }
            }
        }
        
    }
    
    
}
```

## 8.3拓扑排序算法

适用范围：要求有向图，且有入度为0的节点，且没有环。

```java
public class Solution{
    public static List<Node> sortedTopology(Graph graph){
        
        //存放节点及节点对应的入度
        Map<Node,Integer> inMap = new HashMap<>();
        //入度为0的节点进入此队列
        Queue<Node> queue = new LinkedList<>();
        
        for(Node node : graph.nodes.values()){
            inMap.put(node,node.in);
            if(node.in == 0){
                queue.add(node);
            }
        }
        //存放拓扑排序结果
        List<Node> result = new LinkedList<>();
        
        while(!queue.isEmpty()){
            Node cur = queue.poll();
            
            for(Node node : cur.nexts){
                inMap.put(node,inMap.get(node) - 1);
                if(node.in == 0){
                    queue.add(node);
                }
            }
            
        }
        
        return result;
    }
}
```

## 8.4Kruskal算法

适用范围：要求无向图

```java
public class Solution{
    public static class MySets{
        public Map<Node,List<Node>> setMap;
        
        public MySets(List<Node> nodes){
            setMap = new HashMap<>();
            for(Node cur : nodes){
                List<Node> set = new ArrayList<>();
                set.add(cur);
                setMap.put(cur,set);
            }
        }
        
        public boolean isSameSet(Node from,Node to){
            return setMap.get(from) == setMap.get(to);
        }
        
        public void union(Node from,Node to){
            List<Node> fromSet setMap.get(from);
            List<Node> toSet setMap.get(to);
            for(Node toNode : toSet){
                fromSet.add(toNode);
                setMap.put(toNode,fromSet);
            }
        }
    }
    
    //比较器
    public static class EdgeComparator implements Comparator<Edge>{
        @Override
        public int compare(Edge o1,Edge o2){
            return o1.weight - o2.weight;
        }
    }
    
    
    public static Set<Edge> kruskalMST(Graph graph){
        MySets mySets = new MySets(graph.nodes);
        
        //优先级队列排序
        PriorityQueue<Node> priorityQueue = new ProorityQueue<>();
        for(Edge edge : graph.edges){
            priorityQueue.add(edge);
        }
        
        Set<Edge> result = new HashSet<>();
        while(!priorityQueue.isEmpty()){
            Edge edge = priorityQueue.poll();
            if(!mySets.isSameSet(edge.from,edge.to)){
                mySets.union(edge.from,edge.to);
                result.add(edge);
            }
        }
        return result;
        
    }
    
    
}
```

## 8.5Prim算法

适用范围：要求无向图

```java
public class Solution{
    
    public static class EdgeComparator implements Comparator<Edge>{
        @Overrride
        public int compare(Edge o1,Edge o2){
            return o1.weight - o2.weight;
        }
    }
    
    public static Set<Edge> primMST(Graph graph){
        Set<Node> set = new HashSet<>();
        Set<Edge> result = new HashSet<>();
        PriorityQueue<Edge> priorityQueue = new PriorityQueue<>();
        
        //for循环，处理不是连通图的情况，各连通图生成最小生成树
        for(Node node : graph.nodes.values()){
            set.add(node);
            for(Edge edge : node.edges){
                priorityQueue.add(edge);
            }
            
            while(!priorityQueue.isEmpty()){
                Edge edge = priorityQueue.poll();
                Node toNode = edge.to;
                
                if(!set.contains(toNode)){
                    set.add(toNode);
                    result.add(edge);
                    for(Edge edge : toNode.edges){
                        priorityQueue.add(edge);
                    }
                }
                
            }
            
        }
        
        return result;
        
    }
    
    
    
}
```

## 8.6Dijkstra最短路径算法

```java
public class Solution{
    
    public static Map<Node,Integer> dijkstra1(Node head){
		//从head出发到所有点的最小距离
        //key：从head出发到达key
        //value：从head出发到达key的最小距离
        //如果在表中。没有T的记录，含义是从head出发到T这个点的距离为正无穷
        
        Map<Node,Integer> distanceMap = new HashMap<>();
        distanceMap.put(head,0);
        
        Set<Node> selectedNodes = new HashSet<>();
        
        Node minNode = getMinDistanceAandUnSelectedNode(distanceMap,selectedNodes);
        
        while(minNode != null){
            int distance = distanceMap.get(minNode);
            for(Edge edge : minNode.edges){
                Node toNode = edge.to;
                if(!distanceMap.containsKey(toNode)){
                    distanceMap.put(toNode,distanceMap.get(toNode) + edge.weight);
                }
                
                distanceMap.put(toNode,Math.min(distanceMap.get(toNode),distanceMap.get(toNode) + edge.weight));
                minNode = getMinDistanceAandUnSelectedNode(distanceMap,touchedNodes);
            }
        }
        
        return distanceMap;
    }
    
    public static Node getMinDistanceAandUnSelectedNode(Map<Node,Integer> distanceMap,Set<Node> touchedNodes){
        
        Node minNode = null;
        int minDsitance = Integer.MAX_VALUE;
        
        for(Entry<Node,Integr> entry : distanceMap.entrySet()){
            Node node = entry.getKey();
            int distance = entry.getValue();
            
            if(touchedNodes.coantains(node) && distance < minDistance){
                minNode = node;
                minDistance = distance;
            }
        }
        
        return minNode;
    }
    
}
```

改进的Dijkstra算法

```java
public class Solution{
    
    public static class NodeHeap{
        private Node[] nodes;
        private Map<Node,Integer> heapIndexMap;
        private Map<Node,Integer> distanceMap;
        private int size;
        
        public NodeHeap(int size){
            nodes = new Node[size];
            heapIndexMap = new HashMap<>();
            distanceMap = new HashMap<>();
            this.size = 0;//记录堆上实际有几个节点
        }
        
        public boolean isEmpty(){
            return size == 0;
        }
        
        public void addOrUpdateOrIgnore(Node node,int distance){
            //在堆上
            if(inHeap(node)){
                distanceMap.put(node,Math.min(distanceMap.get(node),distance));
                insertHeapify(node,heapIndexMap.get(node));
            }
            //没有进入过堆
            if(!isEntered(node)){
                nodes[size] = node;
                heapIndexMap.put(node,size);
                distanceMap.put(node,distance);
                insertHeapify(node,size++);
            }
        }
        
        public NodeRecord pop(){
            NodeRecord nodeRecord = new NodeRecord(nodes[0],distanceMap.get(nodes[0]));
            swap(0,size - 1);
            heapIndexMap.put(nodes[size - 1],-1);
            distanceMap.remove(nodes[size - 1]);
            nodes[size - 1] = null;
            heapify(0,--size);
            return nodeRecord;
        }
        
        private void insertHeapify(Node node,int index){
            while(distanceMap.get(nodes[index]) < distanceMap.get(nodes[(index - 1) / 2])){
                swap(index,(index - 1) / 2);
                index = (index - 1) / 2;
            }
        }
        
        private void heapify(int index,int size){
            int left = index * 2 + 1;
            while(left < size){
                int smallest = left + 1 < size && distanceMap.get(nodes[left + 1]) < distanceMap.get(nodes[left])? left + 1:left;
                smallest = distanceMap.get(nodes[smallest]) < distanceMap.get(nodes[idnex])? smallset:index;
                if(smallest == index){
                    break;
                }
                swap(smallest,index);
                index = smallest;
                left = index * 2 + 1;
            }
        }
        
        
        private boolean isEntered(Node node){
            return heapIndexMap.containsKey(node);
        }
        
        private boolean inHeap(Node node){
            return isEntered(node) && heapIndexMap.get(node) != -1;
        }
        
        private void swap(int index1,int index2){
            heapIndexMap.put(nodes[index1],index2);
            heapIndexMap.put(nodes[index2],index1);
            Node tmp = nodes[index1];
            nodes[index1] = nodes[index2];
            nodes[index2] = tmp;
        }
    }
    
    public static class NodeRecord{
        public Node node;
        public int distance;
        
        public NodeRecord(Node node,int distance){
            this.node = node;
            this.distance = distance;
        }
    }
    
    public static Map<Node,Integer> dijkstra2(Node head,int size){
        NodeHeap nodeHeap = new NodeHeap(size);
        nodeHeap.addOrUpdateOrIgnore(head,0);
        Map<Node,Integer> result = new HashMap<>();
        while(!nodeHeap.isEmpty()){
            NodeRecord record = nodeHeap.pop();
            Node cur = record.node;
            int distance = record.distance;
            for(Edge edge : cur.edges){
                nodeHeap.addOrUpdateOrIgnore(edge.to,distance + edge.weight);
            }
            result.put(cur,distance);
        }
        return result;
    }
}
```



# 9.前缀树

介绍前缀树

何为前缀树？如何生成前缀树？

例子：

一个字符串类型的数组arr1，另一个字符串类型的数组arr2。arr2中有哪些字符，是arr1中出现的？请打印。arr2中有哪些字符，是作为arr1中某个字符串前缀出现的？请打印。arr2中有哪些字符，是作为arr1中某个字符串前缀出现的？请打印arr2中出现次数最大的前缀。

```java
public class Solution{
    public static class TrieNode{
        public int pass;
        public int end;
        public TrieNode[] nexts;
        
        public TrieNode(){
            pass = 0;
            end = 0;
            //next[0]没有走向'a'的路
            //next[1]没有走向'b'的路
            //...
            nexts = TrieNode[26];//HashMap<Character,Node> nexts;TreeMap<Character,Node> nexts;
        }
    }
    
    public static class Trie{
        private TreeNode root;
        
        public Trie(){
            root = new TrieNode();
        }
        
        public void insert(String word){
            
            if(word == null){
                return;
            }
            
            char[] chs = word.toCharArray();
            TrieNode node = root;
            root.pass++;
            int index = 0;
            for(int i = 0;i < chs.length;i++){
                index = chs[i] - 'a';
                if(node.nexts[index] == null){
                    node.nexts[index] = new TrieNode();
                }
                node = node.nexts[index];
                node.pass++;
            }
            node.end++;
        }
        
        public void delete(String word){
            if(search(word) != 0){
                char[] chs = word.toCharArray();
                TrieNode node = root;
                index = 0;
                for(int i = 0;i < chs.length;i++){
                    index = chs[i] - 'a';
                    if(--node.nexts[index].pass == 0){
                        node.nexts[index] = null;
                        return;
                    }
                    node = node.nexts[index];
                }
                node.end--;
            }
        }
        
        
        //word这个单词之前加入过几次
        public int search(String word){
            if(word == null){
                return 0;
            }
            char[] chs = word.toCharArray();
            TrieNode node = root;
            int index = 0;
            for(int i = 0;i < chs.length;i++){
                index = chs[i] - 'a';
                if(node.nexts[index] == null){
                    return 0;
                }
                node = node.nexts[index];
            }
            return node.end;
        }
        
        //所有加入的字符串中，有几个是以pre这个字符串作为前缀的
        public int prefixNumber(String pre){
            if(pre == null){
                return 0;
            }
            char[] chs =  pre.toCharArray();
            TrieNode node = root;
            int index = 0;
            for(int i = 0;i < chs.length;i++){
                index = chs[i] - 'a';
                if(node.nexts[index] == null){
                    return 0;
                }
                node = node.nexts[index];
                
            }
            return node.pass;
            
        }
        
        
    }
}
```

# 10.贪心算法

在某一个标准下，优先考虑最满足标准的样本，最后考虑最不满足的样本，最终得到一个答案的算法，叫做贪心算法。

也就是说，不从整体最优上加以考虑，所做出的是在某种意义上的额局部最优解。

局部最优-?->整体最优

【题目】一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。给你每一个项目开始的时间和结束的时间（给你一个数组，里面是一个个具体的项目），你来安排宣讲的日程，要求会议室进行宣讲的场次最多。

返回这个最多的宣讲次数

```java
public class Solution{
    public static class Program{
        public int start;
        public int end;
        
        public Program(int start,int end){
            this.start = start;
            this.end = end;
        }
        
    }
    
    public static class ProgramComparator implements Comparator<Program>{
        @Override
        public int compare(Program o1,Program o2){
            return o1.end - o2.end;
        }
    }
    
    public static int bestArrange(Program[] programs,int timePoint){
        Arrays.sort(programs,new ProgramComparator());
        int result = 0;
        
        for(int i = 0;i < programs.length;i++){
            if(timePoint <= programs[i].start){
                timePoint = programs[i].end;
                result++;
            }
        }
        return result;
    }
}
```

贪心策略在实现时，经常使用到的技巧

1.根据某标准建立一个比较器来排序

2.根据某标准建立一个比较器来组成堆

【题目】一块金条切成两半，是需要花费和长度数值一样的铜板的。比如长度为20的金条，不管切成长度多大的两半，都要花费20个铜板。

一群人想分整块金条，怎么分最省铜板？

例如，给定数组[10,20,30]，代表一共三个人，整块金条长度为10+20+30=60.金条要分成10，20，30三个部分。如果先把长度60的金条分成10和50，花费60；再把长度50的金条分成20和30，花费50；一共花费110铜板。

但是如果先把长度60的金条分成30和30，花费60；再把长度30的金条分成10和20，花费30；一共花费90铜板。

输入一个数组，返回分割的最小代价。

```java
public class Solution{
    public static int lessMoney(int[] arr){
        PriorityQueue<Integer> pQ = new PriorityQueue<>();
        for(int i = 0;i < arr.length;i++){
            pQ.add(arr[i]);
        }
        int sum = 0;
        int cur = 0;
        while(pQ.size() > 1){
            cur = pQ.poll() + pQ.poll();
            sum += cur;
            pQ.add(cur);
        }
        return sum;
    }
    
    public static MinheapComparator implements Comparator<Integer>{
        @Override
        public int compare(Integer o1,Integer o2){
            return o1 - o2;
        }
    }
}
```

【题目】输入：

正数数组costs

正数数组profits

正数k

正数m

含义：

cost[i]表示i号项目的花费

profits[i]表示i号项目在扣除花费之后还能挣到的钱（利润）

k表示你只能串行的最多做k个项目

m表示你初始的资金

说明：

你每做完一个项目，马上获得的收益，可以支持你去做下一个项目

输出：

你最后获得的最大钱数。

```java
public class Solution{
    
    public static class Node{
        public int p;
        public int c;
        public Node(int p,int c){
            this.p = p;
            this.c = c;
        }
    }
    
    public static class MinCostComparator implements Comparator<Node>{
    	@Override
        public int compare(Node o1,Node o2){
            return o1.c - o2.c;
        }
    }
    
    public static class MaxProfitComparator implements Comparator<Node>{
        @Override
        public int compare(Node o1,Node o2){
            return o2.p - o1.p;
        }
    }
    
    public static int findMaximizedCapital(int k,int W,int[] profits,int[] Capital){
        PriorityQueue<Node> minCostQ = new PriorityQueue<>(new MinCostComparator());
        PriorityQueue<Node> maxProfitQ = new PriorityQueue<>(new MaxProfitComparator());
        
        for(int i = 0;i < Capital.length;i++){
            minCostQ.add(new Node(profits[i],Capital[i]));
        }
        
        for(int i = 0;i < k;i++){
            while(!minCostQ.isEmpty() && minCostQ.c <= W){
                maxProfitQ.add(minCostQ.poll());
            }
            
            if(maxProfitQ.isEmpty()){
                return W;
            }
            
            W = W + maxProfitQ.poll();
        }
    }
    
    
    
}
```

# 11.暴力递归

暴力递归就是尝试

1，把问题转化为规模缩小了的同类问题的子问题

2，有明确的不需要进行递归的条件

3，有当得到了子问题的结果之后的决策过程

4，不记录每一个子问题的解

一定要学会怎么去尝试，因为这是动态规划的基础，这一内容我们将在提升班讲述

汉诺塔问题

打印n层汉诺塔从最左边移动到最右边的全部过程

```java
public class Solution{
    public static void hanoi(int n){
        if(n > 0){
            func(n,"左","右","中")
        }
    }
    
    public static void func(int i,String start,String end,String other){
        if(i == 1){
            System.out.println("Move 1 from " + start + " to " + end);
            return;
        }
        func(i - 1,start,other,end);
        System.out.println("Move " + i + " from " + start + " to " + end);
        func(i - 1,other,end,start);
    }
    
}
```

打印一个字符串的全部子序列，包括空字符串

```java
public class Solution{
    
    
    public static void printAllSubsequence(String str){
        char[] chs = str.toCharArray();
        process(chs,0);
    }
    
    public static void process(char[] str,int i){
        if(i == str.length){
            System.out.println(String.valueOf(str));
            return;
        }
        process(str,i + 1);
        char tmp = str[i];
        str[i] = 0;
        process(str,i + 1);
        str[i] = tmp;
    }
    
    
    public static void function(String str){
        char[] chs = str.toCharArray();
        List<Character> list = new ArrayList<>();
        process(chs,0,list);
    }
    //当前来到i位置，要和不要，走两条路
    //res之前的选所形成的列表
    public static void process(char[] str,int i,List<Character> res){
        if(i == str.length){
            printList(res);
            return;
        }
        List<Character> resKeep = copyList(res);
        resKeep.add(str[i]);
        process(str,i + 1,resKeep);
        List<Character> resNoInclude = copyList(res);
        process(str,i + 1,resNoInclude);
    }
    
    public static void printList(List<Character> res){
        // ...
        for(Character ch : res){
            System.out.print(ch);
        }
        System.out.println();
    }
    
    public static List<Character> copyList(List<Character> res){
        List<Character> resKeep = new ArrayList<>();
        for(Character ch : res){
            resKeep.add(ch);
        }
        return resKeep;
    }
}
```

打印一个字符串的全部排列

打印一个字符串的全部排列，要求不出现重复的排列

```java
public class Solution{
    public static List<String> permutation(String str){
        List<String> res = new ArrayList<>();
        if(str == null || str.length == 0){
            return res;
        }
        
        char[] chs = str.toCharArray();
        process(chs,0,res);
        return res;
    }
    
    public static void process(char[] chs,int i,List<String> res){
        if(i == chs.length){
            res.add(String.valueOf(chs));
        }
        boolean[] visit = new boolean[26];
        for(int j = i;j < chs.length;j++){
            if(!visit[chs[j] - 'a']){
                visit[chs[j] - 'a'] = true;
                swap(chs,i,j);
                process(chs,i + 1,res);
                swap(chs,i,j);
            }
        }
    }
    
    public static void swap(char[] chs,int i,int j){
        char tmp = chs[i];
        chs[i] = chs[j];
        chs[j] = tmp;
    }
    
}
```

给定一个整型数组arr，代表数值不同的纸牌排成一条线。玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿，但是每个玩家只能拿走最左或最右的纸牌，玩家A和玩家B都绝顶聪明。请返回最后获胜者的分数。

举例

arr=[1,2,100,4]

开始时，玩家A只能拿走1或4。如果开始玩家A拿走1，则排列变为[2,100,4]，接下来玩家B可以拿走2或者4，然后继续轮到玩家A...

如果开始玩家A拿走4，则排列变为[1,2,100]，接下来玩家B可以拿走1或者100，然后继续轮到玩家A...

玩家A作为绝顶聪明的人不会先拿走4，因为拿4之后，玩家B将拿走100.所以玩家A会先拿走1，让排列变为[2,100,4]，接下来玩家B不管怎么选，100都会被玩家A拿走。玩家A会获胜，分数变为101。所以返回101。

arr=[1,100,2]。

开始时，玩家A不管拿1还是2，玩家B作为绝顶聪明的人，都会把100拿走。玩家B会获胜，分数为100，所以返回100。

```java
public class Solution{
    public static int win1(int[] arr){
        if(arr == null || arr.length == 0){
            return 0;
        }
        
        return Math.max(f(arr,0,arr.length - 1),s(arr,0,arr.length - 1));
    }
    
    public static int f(int[] arr,int i,int j){
        if(i == j){
            return arr[i];
        }
        
        return Math.max(arr[i] + s(arr,i + 1,j),arr[j] + s(arr,i,j - 1));
    }
    
    public static int s(int[] arr,int i,int j){
        if(i == j){
            return 0;
        }
        //对手绝顶聪明，会把剩下的最差情况留给玩家
        return Math.min(f(arr,i + 1,j),f(arr,i,j - 1));
        
    }
}
```

一个栈，请逆序这个栈，不能申请额外的数据结构，只能使用递归函数，如何实现？

```java
public class Solution{
    
    public static void reverse(Stack<Integer> stack){
        if(stack.isEmpty()){
            return;
        }
        int i = f(stack);
        reverse(stack);
        stack.push(i);
    }
    
    public static int f(Stack<Integer> stack){
        int result = stack.pop();
        if(stack.isEmpty()){
            return result;
        }
        int last = f(stack);
        stack.push(result);
        return last;
    }
}
```

规定1和A对应，2和B对应，3和C对应...

那么一个数字字符串比如"111"，就可以转化为"AAA"、"KA"、"AK"。

给定一个只有数字字符组成的字符串str，返回有多少种转化结果。

```java
public class Solution{
    public static int process(char[] chs,int i){
        if(i == chs.length){
            return 1;
        }
        
        if(chs[i] == '0'){
            return 0;
        }
        
        if(chs[i] == '1'){
            int res = process(chs,i + 1);//i自己作为单独部分，后续有多少种方法
            if(i + 1 < chs.length){
                res += process(chs,i + 2);//i和i+1作为单独部分，后续有多少种方法
            }
            return res;
        }
        if(chs[i] == '2'){
            int res = process(chs,i + 1);//i自己作为单独部分，后续有多少种方法
            //i和i+1作为单独的部分并且没有超过26，后续有多少种方法
            if(i + 1 < chs.length && chs[i + 1] <= '6' && chs[i + 1] >= '0'){
                res += process(chs,i + 2);
            }
        }
        return process(chs,i + 1);
    }
}
```

给定两个长度都为N的数组weights和values，weights[i]和values[i]分别代表i号物品的重量和价值。给定一个正数bag，表示一个载重bag的袋子，装的物品不能超过这个重量。返回能装下最多的价值是多是？

```java
public class Solution{
    public static int process(int[] weights,int[] values,int i,int alreadyWeight,int bag){
        if(alreadyWeight > bag){
            return 0;
        }
        if(i == weights.length){
            return 0;
        }
        return Math.max(process(weights,values,i + 1,alreadyWeight,bag),values[i] + process(weights,values,i + 1,alreadyWeight + weights[i],bag));
        
    }
}
```

N皇后问题是指在N*N的棋盘上要摆N个皇后，要求任何两个皇后不同行，不同列，也不在同一条斜线上。

给定一个整数n，返回n皇后的摆法有多少种。

n=1，返回1。

n=2或3，2皇后和3皇后问题无论怎么摆都不行，返回0。

n=8，返回92。

```java
public class Solution{
    public static int num1(int n){
        
        if(n < 1){
            return 0;
        }
        int[] record = new int[n];
        
        return process1(0,record,n);
    }
    public static int process1(int i,int[] record,int n){
        if(i == n){
            return 1;
        }
        
        int res = 0;
        for(int j = i;j < n;j++){
            if(isValid(record,i,j)){
                record[i] = j;
                res += process1(i + 1,record,n);
            }
        }
        return res;
    }
    
    public static boolean isValid(int[] record,int i,int j){
        for(int k = 0;k < i;k++){
            if(record[k] == j || Math.abs(record[k] - j) == Math.abs(k - i)){
                return false;
            }
        }
        return true;
    }
 	
    public static int num2(int n){
        //请不要超过32皇后问题
        if(n < 1 || n > 32){
            return 0;
        }
        
        int upperLim = n == 32? -1:(1 << n) - 1;
        return process2(upperLim,0,0,0);
        
        //colLim 列的限制，1的位置不能放皇后，0的位置可以
        //leftDiaLim 左斜线限制，1的位置不能放皇后，0的位置可以
        //rightDiaLim 右斜线限制，1的位置不能放皇后，0的位置可以
        
        public int process2(int upperLim,int colLim,int leftDiaLim,int rightDiaLim){
            if(colLim == upperLim){
                return 1;
            }
            
            int pos = 0;
            int mostRightOne = 0;
            pos = limit & (~(colLim | leftDiaLim | rightDiaLim));
            while(pos != 0){
                mostRightOne = pos & (~pos + 1);
                pos = pos - mostRightOne;
                res += process2(upperLim,colLim | mostRightOne,(leftDiaLim | mostRightOne) << 1,(rightDiaLim | mostRightOne) >>> 1);
                
            }
            return res;
            
        }
        
    }
    
}
```

# 12.哈希函数与哈希表

认识哈希函数和哈希表的实现

设计RandomPool

设计一种结构，在该结构中有如下三个功能：

























